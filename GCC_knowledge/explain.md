GCC Compiler

Linker Options :
-o   						编译后输出文件名
-g						在目标文件中添加调试信息，便于gdb调试或objdump反汇编
-static     					采用静态连接的方式连接程序
-shared      					生成可共享的被其他程序连接的目标模块


# 动态连接方式生成可执行程序
gcc xxx.c -o xxx	
# 静态连接的可执行程序
gcc -static xxx.c -o xxx

# 交叉编译使用 Linaro
# linux x86平台下 编译成 arm64 下的可执行文件。(由于arm平台上可能没有对应的动态链接库,所以采用静态编译)
arm-linux-gnueabihf-gcc -static xxx.c -o xxx



## 编译相关的知识
静态编译
静态编译，就是编译器在编译可执行文件的时候，将可执行文件需要调用的对应静态链接库(.a或.lib)中的部分提取出来，链接到可执行文件中去，使可执行文件在运行的时候不依赖于静态链接库。

动态编译
动态编译的可执行文件需要附带一个动态链接库。在执行时，需要调用其对应动态链接库中的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点一是哪怕是很简单的程序，只用到了链接库中的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。

静态链接库
静态链接库就是把(lib)文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件；

动态链接库
动态链接库就是把调用的函数所在文件模块（DLL）和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从DLL中寻找相应函数代码，因此需要相应DLL文件的支持。

静态链接库和动态链接库的区别
静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib 中的指令都全部被直接包含在最终生成的 EXE 文件中了。但是若使用 DLL，该 DLL 不必被包含在最终 EXE 文件中，EXE 文件执行时可以“动态”地引用和卸载这个与 EXE 独立的 DLL 文件。
静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。动态库就是在需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。如果在当前工程中有多处对dll文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但是如果有多处对lib文件中同一个函数的调用，那么执行时，该函数将在当前程序的执行空间里留下多份拷贝，而且是一处调用就产生一份拷贝。
