AArch64 常用汇编指令

转移指令
mov     寄存器与寄存器或者寄存器与常量之间传值,指令中立即数范围为-65536~65535(17位),不能用于内存地址
mov x0,0x100            ;将立即数0x100 加载到 x0
mov x1,x0               ;将寄存器x0的值传送到寄存器x1

加载/存储指令
ldr     (load register)读取指令,将数据从内存中读取出来,存到寄存器中
ldr x0, [x1] 		    ;将x1寄存器对应内存处的数据加载到x0寄存器
ldr x1, 0x8 		    ;内存[pc + 0x8]数据填充到x1寄存器

str     (store register)写入指令,将数据从寄存器中读出来,写入到内存中
str x0, [sp, #0x8]      ;将寄存器 x0 中的值保存到栈内存 [sp + 0x8] 处 


判断
cmp <wn>, #<imm>        ;该指令中#<imm>为无符号立即数,取值范围为0~4095 (12 bit)


数据处理指令
add     两个数相加
add x0, x0, #1          ; 将寄存器 x0 的值和常量 1 相加后保存在寄存器 x0 中 
add x0, x1, x2          ; 将寄存器 x1 和 x2 的值相加后保存到寄存器 x0 中 
add x0, x1, [x2]        ; 将寄存器 x1 的值加上寄存器 x2 的值作为地址,再取该内存地址的内容放入寄存器 x0 中

sub     两个数相减
sub x0, x1, x2          ; 将寄存器 x1 和 x2 的值相减后保存到寄存器 x0 中 


寻址
相对地址寻址(目标地址是相对PC的偏移地址)
B       只跳转
BL      会把下一条指令地址保存到LR(x30)寄存器里,当子程序执行完了也能借助LR(x30)寄存器跳转回到主程序继续执行

最大寻址范围: 128m

例子
b 8                     ;跳转到PC+8的地方去执行

绝对地址寻址
BR      只跳转
BLR     会把下一条指令地址保存到LR(x30)寄存器里,当子程序执行完了也能借助LR(x30)寄存器跳转回到主程序继续执行

例子
mov x0, 0x400000        ;把0x400000地址赋值给x0寄存器
br x0                   ;跳转到0x400000去


ADRP  {cond}  Rd  label
功能: 以页为单位的大范围的地址读取指令,这里的P就是page的意思
原理: 符号扩展一个21位的offset(immhi+immlo),  向左移动12位,PC的值的低12位清零,然后把这两者相加,结果写入到Rd寄存器,用来得到一块含有lable的4KB对齐内存区域的base地址(也就是说lable所在的地址,一定落在这个4KB的内存区域里,指令助记符里Page也就是这个意思), 
可用来寻址 +/- 4GB的范围(2^33次幂)。通俗来讲,ADRP指令就是先进行PC+imm(偏移值)然后找到lable所在的一个4KB的页,然后取得label的基址

:lo12:label 
取 label 低12位 即页内偏移offset
